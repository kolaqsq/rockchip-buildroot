From 413c90d286007e37da5e2f47fcabcb4ac0076127 Mon Sep 17 00:00:00 2001
From: Jeffy Chen <jeffy.chen@rock-chips.com>
Date: Fri, 29 Mar 2024 16:27:01 +0800
Subject: [PATCH 011/100] gl-renderer: Support NV24 shm format

Some HDMI input devices may provide NV24 images.

Tested with:
gst-launch-1.0 videotestsrc ! 'video/x-raw,format=NV24' ! waylandsink

Signed-off-by: Jeffy Chen <jeffy.chen@rock-chips.com>
---
 libweston/renderer-gl/gl-renderer.c | 12 ++++++
 tests/yuv-buffer-test.c             | 58 +++++++++++++++++++++++++++++
 2 files changed, 70 insertions(+)

diff --git a/libweston/renderer-gl/gl-renderer.c b/libweston/renderer-gl/gl-renderer.c
index 5b888b21b..3f84693f8 100644
--- a/libweston/renderer-gl/gl-renderer.c
+++ b/libweston/renderer-gl/gl-renderer.c
@@ -292,6 +292,17 @@ struct yuv_format_descriptor yuv_formats[] = {
 			.format = DRM_FORMAT_GR88,
 			.plane_index = 1
 		}}
+	}, {
+		.format = DRM_FORMAT_NV24,
+		.output_planes = 2,
+		.shader_variant = SHADER_VARIANT_Y_UV,
+		{{
+			.format = DRM_FORMAT_R8,
+			.plane_index = 0
+		}, {
+			.format = DRM_FORMAT_GR88,
+			.plane_index = 1
+		}}
 	}, {
 		.format = DRM_FORMAT_P010,
 		.output_planes = 2,
@@ -4023,6 +4034,7 @@ gl_renderer_display_create(struct weston_compositor *ec,
 	wl_display_add_shm_format(ec->wl_display, WL_SHM_FORMAT_YUV444);
 	wl_display_add_shm_format(ec->wl_display, WL_SHM_FORMAT_NV12);
 	wl_display_add_shm_format(ec->wl_display, WL_SHM_FORMAT_NV16);
+	wl_display_add_shm_format(ec->wl_display, WL_SHM_FORMAT_NV24);
 	wl_display_add_shm_format(ec->wl_display, WL_SHM_FORMAT_YUYV);
 	wl_display_add_shm_format(ec->wl_display, WL_SHM_FORMAT_XYUV8888);
 	wl_display_add_shm_format(ec->wl_display, WL_SHM_FORMAT_ABGR8888);
diff --git a/tests/yuv-buffer-test.c b/tests/yuv-buffer-test.c
index 8bbb6fa42..737eb05aa 100644
--- a/tests/yuv-buffer-test.c
+++ b/tests/yuv-buffer-test.c
@@ -351,6 +351,63 @@ nv16_create_buffer(struct client *client,
 	return buf;
 }
 
+/*
+ * 2 plane YCbCr
+ * plane 0 = Y plane, [7:0] Y
+ * plane 1 = Cr:Cb plane, [15:0] Cr:Cb little endian
+ * non-subsampled Cr:Cb plane
+ */
+static struct yuv_buffer *
+nv24_create_buffer(struct client *client,
+		   uint32_t drm_format,
+		   pixman_image_t *rgb_image)
+{
+	struct image_header rgb = image_header_from(rgb_image);
+	struct yuv_buffer *buf;
+	size_t bytes;
+	int x, y;
+	uint32_t *rgb_row;
+	uint8_t *y_base;
+	uint16_t *uv_base;
+	uint8_t *y_row;
+	uint16_t *uv_row;
+	uint32_t argb;
+	uint8_t cr;
+	uint8_t cb;
+
+	assert(drm_format == DRM_FORMAT_NV24);
+
+	/* Full size Y, non-subsampled UV */
+	bytes = rgb.width * rgb.height +
+		rgb.width * rgb.height * sizeof(uint16_t);
+	buf = yuv_buffer_create(client, bytes, rgb.width, rgb.height,
+				rgb.width, drm_format);
+
+	y_base = buf->data;
+	uv_base = (uint16_t *)(y_base + rgb.width * rgb.height);
+
+	for (y = 0; y < rgb.height; y++) {
+		rgb_row = image_header_get_row_u32(&rgb, y / 2 * 2);
+		y_row = y_base + y * rgb.width;
+		uv_row = uv_base + y * rgb.width;
+
+		for (x = 0; x < rgb.width; x++) {
+			/*
+			 * 2x2 sub-sample the source image to get the same
+			 * result as the other YUV variants, so we can use the
+			 * same reference image for checking.
+			 */
+			argb = *(rgb_row + x / 2 * 2);
+
+			x8r8g8b8_to_ycbcr8_bt601(argb, y_row + x,
+						 &cb, &cr);
+			*(uv_row + x) = ((uint16_t)cr << 8) | cb;
+		}
+	}
+
+	return buf;
+}
+
 /*
  * Packed YCbCr
  *
@@ -483,6 +540,7 @@ static const struct yuv_case yuv_cases[] = {
 	{ FMT(YUV444), y_u_v_create_buffer },
 	{ FMT(NV12), nv12_create_buffer },
 	{ FMT(NV16), nv16_create_buffer },
+	{ FMT(NV24), nv24_create_buffer },
 	{ FMT(YUYV), yuyv_create_buffer },
 	{ FMT(XYUV8888), xyuv8888_create_buffer },
 #undef FMT
-- 
2.20.1

