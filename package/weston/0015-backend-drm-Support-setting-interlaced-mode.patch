From 7ef4fbecdf768018187e319a4d468a3cdbb19e7e Mon Sep 17 00:00:00 2001
From: Jeffy Chen <jeffy.chen@rock-chips.com>
Date: Wed, 21 Oct 2020 15:27:38 +0800
Subject: [PATCH 015/100] backend-drm: Support setting interlaced mode

Prefer using DRM mode with matched name.

Signed-off-by: Jeffy Chen <jeffy.chen@rock-chips.com>
---
 libweston/backend-drm/modes.c | 24 ++++++++++++++----------
 1 file changed, 14 insertions(+), 10 deletions(-)

diff --git a/libweston/backend-drm/modes.c b/libweston/backend-drm/modes.c
index 7b4311999..f2f36bf08 100644
--- a/libweston/backend-drm/modes.c
+++ b/libweston/backend-drm/modes.c
@@ -522,8 +522,8 @@ drm_output_print_modes(struct drm_output *output)
 		dm = to_drm_mode(m);
 
 		aspect_ratio = aspect_ratio_to_string(m->aspect_ratio);
-		weston_log_continue(STAMP_SPACE "%dx%d@%.1f%s%s%s, %.1f MHz\n",
-				    m->width, m->height, m->refresh / 1000.0,
+		weston_log_continue(STAMP_SPACE "%s@%.1f%s%s%s, %.1f MHz\n",
+				    dm->mode_info.name, m->refresh / 1000.0,
 				    aspect_ratio,
 				    m->flags & WL_OUTPUT_MODE_PREFERRED ?
 				    ", preferred" : "",
@@ -549,16 +549,19 @@ struct drm_mode *
 drm_output_choose_mode(struct drm_output *output,
 		       struct weston_mode *target_mode)
 {
-	struct drm_mode *tmp_mode = NULL, *mode_fall_back = NULL, *mode;
+	struct drm_mode *tmp_mode = NULL, *mode_fall_back = NULL, *mode, *tmode;
 	enum weston_mode_aspect_ratio src_aspect = WESTON_MODE_PIC_AR_NONE;
 	enum weston_mode_aspect_ratio target_aspect = WESTON_MODE_PIC_AR_NONE;
 	struct drm_device *device;
 
+	mode = to_drm_mode(output->base.current_mode);
+	tmode = to_drm_mode(target_mode);
+
 	device = output->device;
+
 	target_aspect = target_mode->aspect_ratio;
 	src_aspect = output->base.current_mode->aspect_ratio;
-	if (output->base.current_mode->width == target_mode->width &&
-	    output->base.current_mode->height == target_mode->height &&
+	if (!strcmp(mode->mode_info.name, tmode->mode_info.name) &&
 	    (output->base.current_mode->refresh == target_mode->refresh ||
 	     target_mode->refresh == 0)) {
 		if (!device->aspect_ratio_supported || src_aspect == target_aspect)
@@ -568,8 +571,7 @@ drm_output_choose_mode(struct drm_output *output,
 	wl_list_for_each(mode, &output->base.mode_list, base.link) {
 
 		src_aspect = mode->base.aspect_ratio;
-		if (mode->mode_info.hdisplay == target_mode->width &&
-		    mode->mode_info.vdisplay == target_mode->height) {
+		if (!strcmp(mode->mode_info.name, tmode->mode_info.name)) {
 			if (mode->base.refresh == target_mode->refresh ||
 			    target_mode->refresh == 0) {
 				if (!device->aspect_ratio_supported ||
@@ -649,6 +651,7 @@ drm_output_choose_initial_mode(struct drm_device *device,
 	struct drm_mode *best = NULL;
 	struct drm_mode *drm_mode;
 	drmModeModeInfo drm_modeline;
+	char name[16] = "\0";
 	int32_t width = 0;
 	int32_t height = 0;
 	uint32_t refresh = 0;
@@ -658,7 +661,9 @@ drm_output_choose_initial_mode(struct drm_device *device,
 	int n;
 
 	if (mode == WESTON_DRM_BACKEND_OUTPUT_PREFERRED && modeline) {
-		n = sscanf(modeline, "%dx%d@%d %u:%u", &width, &height,
+		sscanf(modeline, "%12[^@pP]", name);
+
+		n = sscanf(modeline, "%dx%d%*[^0-9]%d %u:%u", &width, &height,
 			   &refresh, &aspect_width, &aspect_height);
 		if (device->aspect_ratio_supported && n == 5) {
 			if (aspect_width == 4 && aspect_height == 3)
@@ -688,8 +693,7 @@ drm_output_choose_initial_mode(struct drm_device *device,
 	}
 
 	wl_list_for_each_reverse(drm_mode, &output->base.mode_list, base.link) {
-		if (width == drm_mode->base.width &&
-		    height == drm_mode->base.height &&
+		if (!strcmp(name, drm_mode->mode_info.name) &&
 		    (refresh == 0 || refresh == drm_mode->mode_info.vrefresh)) {
 			if (!device->aspect_ratio_supported ||
 			    aspect_ratio == drm_mode->base.aspect_ratio)
-- 
2.20.1

